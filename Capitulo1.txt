OBJECTIVE 1.1: THOUGHT EXPERIMENT

1. Explain how multithreading can help with your client application.
Improve the responsiveness, when the UI thread process the response from the user and background threads execute other operations 

2. What is the diference between CPU and I/O bound operations?
A CPU-bound operation needs a thread to execute. In a client application, it can make sense to execute a CPU-bound operation on another thread to improve responsiveness. In a server application, you don’t want an extra thread for a CPU-bound operation. Asynchronous I/O operations don’t require a thread while executing. Using asynchronous I/O frees the current thread to do other work and improves scalability.

3. Does using multithreading with the TPL offer the same advantages for your server application?
Using multithreading in a server environment can help you distribute operations over multiple CPUs. This way, you can improve performance. Using the TPL to create another thread to execute a CPU-bound operation while the originating thread has to wait for it won’t help you with increasing performance. 

OBJECTIVE 1.1: REVIEW

1. You have a lot of items that need to be processed. For each item, you need to perform a complex calculation. Which technique should you use?
A. You create a Task for each item and then wait until all tasks are finished.
Incorrect: Manually creating and managing tasks is not necessary. The Parallel class takes care of this and uses the optimal configuration options.
*B. You use Parallel. For to process all items concurrently.
Correct: Parallel. For is ideal for executing parallel operations on a large set of items that have to do a lot of work.
C. You use async/await to process all items concurrently.
Incorrect: async/await does not process items concurrently. Instead it waits until the current task has finished and then continues executing the code.
D. You add all items to a BlockingCollection and process them on a thread created by the Thread class.
Incorrect: The BlockingCollection can be used to share data between multiple threads. Using one producer and one consumer thread, however, won’t improve scalability. The Parallel class is designed for this scenario and should be used.

2. You are creating a complex query that doesn’t require any particular order and you want to run it in parallel. Which method should you use?
*A. AsParallel
Correct: AsParallel makes a sequential query parallel if the runtime thinks this will improve performance.
B. AsSequential
Incorrect: AsSequential is used to make a parallel query sequential again.
C. AsOrdered
AsOrdered is used to make sure that the results of a parallel query are returned in order.
D. WithDegreeOfParallelism
Incorrect: WithDegreeOfParallelism is used to specify how many threads the parallel query should use.

3. You are working on an ASP.NET application that retrieves some data from another web server and then writes the response to the database. Should you use async/await?
A. No, both operations depend on external factors. You need to wait before they are finished.
Incorrect: Because you have to wait for external factors (the database and web response), you should use async/await to free your thread. That way your thread can do some other work while waiting for the external responses to come back.
B. No, in a server application you don’t have to use async/await. It’s only for responsiveness on the client.
Incorrect: Async/await can be used to improve responsiveness on the client but it can also be used in server scenarios. Especially when waiting for an I/O-bound operation, you can use asynchronous code to free the thread from waiting.
*C. Yes, this will free your thread to serve other requests while waiting for the I/O to complete.
Correct: The operating system waits for the I/O request to complete and then activates a thread that can process the response. In the meantime, the thread can do other work.
D. Yes, this put your thread to sleep while waiting for I/O so that it doesn’t use any CPU.
Incorrect: Async/await does not put your thread to sleep in an I/O-bound situation. Instead, your thread can process other work while the operating system monitors the status of the request. When the request finishes, a thread is used to process the response. With a CPU-bound operation, your thread waits for the operation to finish on another thread.

==============================================================================================================================
==============================================================================================================================
OBJECTIVE 1.2: THOUGHT EXPERIMENT

1. How can you orchestrate your locking code to avoid deadlocks?
It’s important to make sure that all locking follows the same order when locking multiple objects. As soon as you start locking dependent objects in different orders, you start getting deadlocks.

2. How can the Interlocked class help you?
The Interlocked class can help you to execute small, atomic operations without the need for locking. When you use locking a lot for these kind of operations, you can replace them with the Interlocked statement.

OBJECTIVE REVIEW

1. You want to synchronize access by using a lock statement. On which member do you lock?
A. this
Incorrect: You should never lock on this. Another part of your code may already be using your object to execute a lock.
B. string _lock = “mylock”
Incorrect: You shouldn’t use a string for locking. With string-interning, one object can be used for multiple strings, so you would be locking on an object that is also in use in other locations.
C. int _lock = 42;
Incorrect: Locking on a value type will generate a compile error. The value type will be boxed each time you lock on it, resulting in a unique lock each time.
*D. object _lock = new object();
Correct: A private lock of type object is the best choice.

2. You need to implement cancellation for a long running task. Which object do you pass to the task?
A. CancellationTokenSource
Incorrect: The CancellationTokenSource is used to generate a CancellationToken. The token should be passed to the task, and the CancellationTokenSource can then be used to request cancellation on the token.
*B. CancellationToken
Correct: A CancellationToken generated by a CancellationTokenSource should be passed to the task.
C. Boolean isCancelled variable
Incorrect: A Boolean variable can be used to cancel a task, but it’s not the preferred way. A CancellationToken offers more flexibility and should be used.
D. Volatile
Incorrect: The volatile keyword should be used to signal to the compiler that the order of reads and writes on a field is important and that the compiler shouldn’t change it.

3. You are implementing a state machine in a multithreaded class. You need to check what the current state is and change it to the new one on each step. Which method do you use?
A. Volatile.Write(ref currentState)
Incorrect: Volatile.Write is used to signal to the compiler that writing the value to a field should happen at that exact location.
*B. Interlocked.CompareExchange(ref currentState, ref newState, expectedState)
Correct: CompareExchange will see whether the current state is correct and it will then change it to the new state in one atomic operation.
C. Interlocked.Exchange(ref currentState, newState)
Incorrect: Exchange only changes the value; it doesn’t check to see whether the current state is correct.
D. Interlocked.Decrement(ref newState)
Incorrect: Decrement is used to subtract one off the value in an atomic operation.

======================================================================================================================
======================================================================================================================
OBJECTIVE 1.3: THOUGHT EXPERIMENT
1. What is the disadvantage of using goto? How can you avoid using the goto statement?
Using the goto statement makes your code much harder to read because the application flow jumps around. goto is mostly used in looping statements. You can then replace goto with while or do-while.
2. Which statement can you use to improve the long if statements?
The switch statement can be used to improve long if statements.
3. What are the differences between the for and foreach statement? When should you use which?
The for statement can be used to iterate over a collection by using an index. You can modify the collection while iterating. You need to use the index to retrieve each item. foreach is syntactic sugar over the iterator pattern. You don’t use an index; instead the compiler gives you a variable that points to each iteration item.

OBJECTIVE REWIEW
1. You need to iterate over a collection in which you know the number of items. You need to remove certain items from the collection. Which statement do you use?
A. switch
Incorrect: switch is used as a decision statement. You map a value to certain labels to execute specific code; it doesn’t iterate over collections.
B. foreach
Incorrect: Although the foreach statement can be used to iterate over a collection; it doesn’t allow changes to the collection while iterating.
*C. for
Correct: With for, you can iterate over the collection while modifying it. It’s your own job to make sure that the index stays correct.
D. goto
Incorrect: goto is a jump statement that should be avoided.

2. You have a lot of checks in your application for null values. If a value is not null, you want to call a method on it. You want to simplify your code. Which technique do you use?
A. for
Incorrect: for is an iteration statement that can’t be used to check for null values.
B. Conditional operator
Incorrect: The conditional operator can be used to shorten if statements. It’s not useful to conditionally call a method.
C. Null-coalescing operator
Incorrect: The null-coalescing operator does check for null values but it’s used to provide a default value. It’s not useful when calling a method if the value is not null.
*D. The short-circuiting behavior of the and operator
Correct: Short-circuiting enables you to see whether a value is null and call a member on it in one and statement. If the left value is null, the right operand won’t be executed.

3. You are processing some data from over the network. You use a HasNext and Read method to retrieve the data. You need to run some code on each item. What do you use?
A. for
Incorrect: A for statement is most useful when iterating over a collection in which you know the number of items beforehand.
B. foreach
Incorrect: foreach can be used only on types that implement IEnumerable. It can’t be easily used with your two custom methods.
*C. while
Correct: You can use while (o.HasNext) { var i = o.Read(); } to process the items. When o.HasNext returns false, you automatically end the loop.
D. do-while
Incorrect: Do-while will run the code at least once. If there are no items on the network, the code doesn’t have to run.

===================================================================================================
===================================================================================================
OBJECTIVE 1.4: THOUGHT EXPERIMENT
You are working on a desktop application that consists of multiple forms. Those forms show different views of the same data and they should update in real time. Your application is extensible, and third parties can add plug-ins that contain their own views of the data.

1. Should you use delegates or events in this system?
Events are a nice layer on top of delegates that make them easier and safer to use. In this case, you should use events to make sure that other users won’t be able to clear all subscriptions. It also makes sure that they can’t raise the event on their own. They can only listen to changes.

2. How can this help you?
The advantage of using an event system in an application like this is that you can achieve loose coupling. Your forms don’t have to know anything about each other. The class that monitors data changes and raises the event doesn’t have to know how many forms are listening and how they look. Third-party plug-ins can easily subscribe to the events at runtime to be able to respond to changes without tightly coupling to the existing system.

OBJECTIVE REWIEW
1. You have a private method in your class and you want to make invocation of the method possible by certain callers. What do you do?
A. Make the method public.
Incorrect: Making the method public gives access to all users of your class.
B. Use an event so outside users can be notified when the method is executed.
Incorrect: This doesn’t give users of your class the ability to execute the method.
*C. Use a method that returns a delegate to authorized callers.
Correct: The method can see whether the caller is authorized and then return a delegate to the private method that can be invoked at will.
D. Declare the private method as a lambda.
Incorrect: Changing the method to a lambda doesn’t change the fact that outside users can’t access the method.

2. You have declared an event on your class, and you want outside users of your class to raise this event. What do you do?
A. Make the event public.
Incorrect: The compiler restricts the use of events outside of the class where it’s defined. They can only add and remove subscribers. Only the class itself can raise the event.
*B. Add a public method to your class that raises the event.
Correct: The public method can be called by outside users of your class. Internally it can raise the event.
C. Use a public delegate instead of an event.
Incorrect: Using a delegate does allow it to be invoked from outside the class. However, you lose the protection that an event gives you. A public delegate can be completely modified by outside users without any restrictions.
D. Use a custom event accessor to give access to outside users.
Incorrect: Canonical name (CNAME) records map an alias or nickname to the real or canonical name that might lie outside the current zone.

3. You are using a multicast delegate with multiple subscribers. You want to make sure that all subscribers are notified, even if an exception is thrown. What do you do?
*A. Manually raise the events by using GetInvocationList.
Correct: You can handle each individual error and make sure that all subscribers are called.
B. Wrap the raising of the event in a try/catch.
Incorrect: Wrapping the raising of the event in one try/catch will still cause the invocation to stop at the first exception. Later subscribers won’t be notified.
C. Nothing. This is the default behavior.
Incorrect: By default, the invocation of subscribers stops when the first unhandled exception happens in one of the subscribers.
D. Let subscribers return true or false instead of throwing an exception.
Incorrect: Exceptions are the preferred way of dealing with errors. Returning a value from each event still requires you to invoke them manually one by one to check the return value. 

=======================================================================================================================
=======================================================================================================================
OBJECTIVE 1.5: THOUGHT EXPERIMENT
 
You are designing a new application and you want to implement a proper errorhandling strategy. You are discussing the topic with some colleagues, and one of them says that you should use regular error codes to signal errors because that’s faster and your company has used it in the past.
You are also having a discussion about when to create a custom exception and when to use the built-in .NET Framework exceptions.
1. Explain to your colleague the advantages of Exceptions compared to error codes.
Exceptions are objects, so they can store extra information that can’t be done with only an error code. The .NET Framework also offers special support for dealing with exceptions. For example, you can use catch blocks to handle certain types of exceptions and you can use a finally block to make sure that certain code will always run.

2. When should you create a custom exception?
You should create a custom exception only if you expect developers to handle it or perform custom logging. If a developer won’t be able to fix the specific error, it won’t make any sense to create a more specific exception. Custom logging can happen when you throw more detailed exceptions, so developers can differentiate between the errors that happen.

OBJECTIVE REWIEW
1. You are checking the arguments of your method for illegal null values. If you encounter a null value, which exception do you throw?
A. ArgumentException.
Incorrect: Although the exception has to do with an argument to your method, you should throw the more specialized ArgumentNullException.
B. InvalidOperationException.
Incorrect: InvalidOperationException should be used when your class is not in the correct state to handle a request.
C. NullReferenceException.
Incorrect: NullReferenceException is thrown by the runtime when you try to reference a null value.
*D. ArgumentNullException.
Correct: ArgumentNullException is the most specialized exception that you can use to tell which argument was null and what you expect.

2. Your code catches an IOException when a file cannot be accessed. You want to give more information to the caller of your code. What do you do?
A. Change the message of the exception and rethrow the exception.
Incorrect: The Message property of an exception is read-only. You can’t change it after the exception is created.
*B. Throw a new exception with extra information that has the IOException as InnerException.
Correct: The new exception can contain extra info. Setting the InnerException makes sure that the original exception stays available.
C. Throw a new exception with more detailed info.
Incorrect: Throwing a brand-new exception loses the original exception and the information that it had.
D. Use throw to rethrow the exception and save the call stack.
Incorrect: Using throw without an identifier will rethrow the original exception while maintaining the stack trace, but it won’t add any extra information.

3. You are creating a custom exception called LogonFailedException. Which constructors should you at least add? (Choose all that apply.)
*A. LogonFailed()
Correct: You should always add a default empty constructor.
*B. LogonFailed(string message)
Correct: A second constructor should take a descriptive message of why the error occurred.
*C. LogonFailed(string message, Exception innerException)
Correct: An InnerException can be set to correlate two exceptions and show what the original error was.
D. LogonFailed(Exception innerException)
Incorrect: You don’t have to define a constructor that only takes an InnerException without a message.

==================================================================================================================
==================================================================================================================
OBJECTIVE 2.1: THOUGHT EXPERIMENT

You are tasked with creating the basic types for a new web shop. As a customer, you can search through the existing product database and compare different items by reviewing specifications and reviews from other users. The system should keep track of popular products and make recommendations to the customer. Of course, the customer can then select the products he wants and place an order. There are also some business rules that you need to be aware of. A new customer is not allowed to place an order that exceeds $500. An order should be at least $10 to qualify for free shipping. More business rules will be added, but are not clear at the moment. Answer the following questions for your manager:
1. Which basic types are you going to use to build your web shop?
Some of the types that you can use in building your web shop are: Order, OrderLine, Product, Customer, Review, SearchCriteria, BusinessRule.
2. How can you make sure that your types contain both behavior and data?
When designing the system, you should focus on the behavior and then make sure that you have the data to support it. For example, instead of publicly exposing the OrderLines that an order contains, you should expose a method AddProduct(product, amount) that creates an OrderLine internally and makes sure that the Order follows all business rules. 
3. How can you improve the usability of your types?
By making sure that you have the correct constructors, users of your types can easily see which data is required. By using enums (for example for the Order status and Customer status), you can improve readability of your code. By using a base class for your business rules you can make the system more extensible so that other business rules can be easily defined.

OBJECTIVE REWIEW

1. You are creating a new collection type and you want to make sure the elements in it can be easily accessed. What should you add to the type?
A. Constructor
Incorrect: A constructor is used to create an instance of a new type.
B. Indexer property
Correct: An indexer property enables the user of the type to easily access a type that represents an array-like collection.
C. Generic type parameter
Incorrect: Making the type generic enables you to store multiple different types inside your collection.
D. Static property
Incorrect: A static property cannot access the instance data of the collection. 

2. You are creating a generic class that should work only with reference types. Which type constraint should you add?
*A. where T : class
Correct: Constraining your generic type parameter to class allows the class to be used only with a reference type.
B. where T : struct
Incorrect: This will constrain the class to be used with a value type, not a reference type.
C. where T : new()
Incorrect: This will constrain the class to be used with a type that has an empty default constructor. It can be both a value and a reference type.
D. where T : IDisposable
Incorrect: This constrains the class to be used with a type that implements the IDisposable interface.

3. You pass a struct variable into a method as an argument. The method changes the variable; however, when the method returns, the variable has not changed. What happened?
A. The variable was not initialized before it was passed in.
Incorrect: Passing a noninitialized struct will result in a compile error of using an unassigned local variable.
B. A value type cannot be changed inside a method.
Incorrect: A struct can be changed inside a method. It won’t change the original struct that was passed in, however.
*C. Passing a value type makes a copy of the data. The original wasn’t changed.
Correct: Passing a struct will make a copy of the data. The copy can be changed; the original won’t change with it.
D. The method didn’t return the changes.
Incorrect: With a reference type, the method can make changes that will reflect on the original. Because a value type is copied, it won’t change the original. Returning the changes from the method will again create a new instance that will overwrite the original.


========================================================================================================================
========================================================================================================================
OBJECTIVE 2.2: THOUGHT EXPERIMENT

You are developing a reusable library for doing complex calculations. Your application is gaining popularity, but you are starting to hear some negative responses. 
Some say that your types cannot be used easily. When displaying the end results of calculations to the end user, there is a lot of manual work involved. 
Others experience performance problems and want you to do something about it. You started developing your application with C# 1.0, and your application uses ArrayLists to keep track of all the 
parameters needed for the calculations. Your parameters are implemented as a struct. 
Your algorithms are implemented in a class hierarchy, and you often need to cast a base type to a derived type. Because this isn’t always possible, you have added a lot of try/catch 
statements to recover from errors. Answer the following questions:
1. How can a generic collection improve performance?
ArrayLists are nongeneric; they can only work with items of type object. Because of this, you have to box and unbox your calculation parameters each time you use them. 
Switching to a generic collection will avoid all the boxing and unboxing and will improve performance.
2. Is there anything you can do to avoid the exceptions when converting between types?
Throwing and catching exceptions is expensive. You can avoid the exceptions when converting items by first making sure that the conversion is allowed by using the is and as keywords. 
You can use a simple Boolean check to see whether a conversion is allowed.
3. How can you ensure your type is better converted to the basic CLR types?
One thing you can do is make sure to implement implicit conversions to the CLR types that you want to support. You could also add a helper class that aids in converting items.

OBJECTIVE REVIEW

1. You are creating a custom Distance class. You want to ease the conversion from your Distance class to a double. What should you add?
A. Nothing; this is already possible.
Incorrect: A conversion between a custom class and a value type does not exist by default.
*B. An implicit cast operator.
Correct: Adding an implicit operator will enable users of your class to convert between Distance and double without any extra work.
C. An explicit cast operator.
Incorrect: Although adding an explicit cast operator will enable users of the class to convert from Distance to double, they will still need to explicitly cast it.
D. A static Parse method.
Incorrect: A Parse method is used when converting a string to a type. It doesn’t add conversions from your type to another type.

2. You want to determine whether the value of an object reference is derived from a particular type. Which C# language feature can you use? (Choose all that apply.)
*A. An as operator
Correct: The as operator will return null if the conversion failed. If it succeeds, it will return the converted object. Seeing whether the result is null enables you to check for a valid conversion.
B. An implicit cast
Incorrect: Implicitly casting something of type object to another type is not possible. It would require an explicit cast.
*C. An is operator
Correct: The is keyword will see whether a type is derived from another type.
D. A dynamic keyword
Incorrect: The dynamic keyword can be used when you want weakly typing. It will still throw errors at runtime if an action is not possible.

3. You are using an ArrayList as a collection for a list of Points, which are a custom struct. You are experiencing performance problems when working with a large amount of Points. 
What do you have to do?
*A. Use a generic collection instead of ArrayList.
Correct: Using a generic collection will eliminate the need to box and unbox values. This will improve performance, especially when working with a large number of items.
B. Change Point to be a reference type.
Incorrect: Changing Point to be a reference type could increase memory usage. You will still have to convert from object to Point when using the nongeneric ArrayList.
C. Add an implicit conversion from Point to object.
Incorrect: Point is a struct that inherits from System.ValueType, which in turn inherits from System.Object. The implicit conversion is already present; adding it won’t improve performance.
D. Make the collection of type dynamic.
Incorrect: Making the collection dynamic will loosen compile-time checking. It won’t improve performance because the runtime has to do extra work.
 
======================================================================================================================
======================================================================================================================
OBJECTIVE 2.3: THOUGHT EXPERIMENT

You are working with a team to create a new application for keeping track of the inventory of a chemistry lab. Your application consists of lots of types that all 
participate in making sure that items are not used by unqualified personnel, dangerous chemicals are not used in the same room, and items are ordered as soon as the
stock is running low.
Currently, all types in the system have different access modifiers. Some types are completely immutable; others expose all their data. You are discussing the current
problems with a colleague. He argues that all types and all type members should be public.
1. Explain to your colleagues why making all members public isn’t the solution.
Making each and every type public will remove all the benefits that encapsulation offers. Encapsulating data means that the internal representation of an object is hidden
from the outside world. This prevents users of your type from setting an invalid or inconsistent state, and also hides complexity. This makes your system more robust because 
you can change implementation details while not changing the public interface of your type.

2. Give an example of how a property can help with encapsulating data while still improving usability.
Because a property offers a controlled way of accessing a field, you can run extra code both on reading and changing the value. You can, for example, make sure that only authorized 
personnel can change specific values that determine who can use a specific chemical. 

3. How can interfaces be used to improve the design?
Because a type can implement multiple interfaces, you can use an interface to expose only a subset of the type members. By using explicit interface implementation, you can
also hide certain members that should be visible under only certain circumstances. This way, you can enhance the public interface of a type by exposing fewer members at a
given time.

OBJECTIVE REVIEW

1. What access modifier should you use to make sure that a method in a class can only be accessed inside the same assembly by derived types?
A. Make the class public and its members public.
Incorrect: A public class with public members can be accessed from other assemblies without any restrictions.
B. Make the class public and its members protected.
Incorrect: Types in other assemblies can derive from the class and access the protected methods.
C. Make the class internal and its members internal.
Incorrect: Types in other assemblies cannot derive from the class, but other types in the same assembly can access the method.
*D. Make the class internal and its members protected.
Correct: An internal class cannot be accessed outside of its assembly. The protected methods can be accessed only by derived types.

2. You need to expose some data from a class. The data can be read by other types but can be changed only by derived types. What should you use?
A. A protected field
Incorrect: A protected field cannot be read by other types outside of the class.
*B. A public property with a protected set modifier
Correct: A public property can be read by all other types. The protected set modifier restricts changes to derived types.
C. A protected property
Incorrect: A protected property cannot be read by other types outside of the class.
D. A protected property with a public get modifier
Incorrect: This will generate a compile error because the accessibility modifier of the get accessor must be more restrictive than the property. Public is less restrictive than protected.

3. You have a class that implements two interfaces that both have a method with the same name. Interface IA should be the default implementation. Interface IB should be used only in special situations. 
How do you implement those interfaces?
*A. Implement IA implicitly and IB explicitly.
Correct: Implementing IA implicitly will make this the default implementation. When dealing with a reference to the class, this method will be invoked. Implementing IB explicitly will invoke the implementation 
for IB when dealing with a reference to the IB interface.
B. Implement both IA and IB explicitly.
Incorrect: When both IA and IB are implemented explicitly, you need to cast a reference to the class to one or both interface types to invoke the method.
C. Implement both IA and IB implicitly.
Incorrect: Implementing both IA and IB implicitly won’t allow for a different implementation for IB.
D. Implement IA explicitly and IB implicitly. 
Incorrect: Implementing IB implicitly makes IB the default implementation instead of IA.

=============================================================================================================================
=============================================================================================================================
OBJECTIVE 2.4: THOUGHT EXPERIMENT


You are working on a brand-new web application for a real estate agent. The agent wants to display his property on a website and ensure that users can easily search
for it. For example, a user will be able to filter the results on location, size, property type, and price. You need to create the infrastructure that uses all the 
selected criteria to filter the list of available houses.

You want to see whether you can use some of the standard interfaces from the .NET Framework to implement your infrastructure.

1. Why does the .NET Framework offer some interfaces without any implementation? Wouldn’t it be easier if the .NET Framework used abstract base classes?
The problem is that C# doesn’t have multiple inheritance for classes, but you can have multiple interface inheritance. When types such as IDisposable 
would be implemented as a base class, you would be able to inherit only from that class. Inheriting from other custom types would be impossible. 

2. Would you use interface or class inheritance to create your search criteria?
Implementing the search criteria can be best done through using class inheritance. By making an abstract class that accepts an input and then executes a specific filter over
the items, you can reuse as much code as possible. The inherited criteria would need to specify only the filter expression (maybe through a lambda) and their exact parameters
through the constructor.

3. Which of the following interfaces would you use?
+IComparable
+IEnumerable
+IDisposable
+IUnknown
IUnknown is not usable in this scenario; it’s only for dealing with unmanaged code. Implementing IDisposable should be used when you are dealing with unmanaged resources that you 
want to free. In this case, that’s not necessary. IComparable could come in handy when you want to order your criteria (for example, one criterion should execute before any of the others). 
IEnumerable can be used to implement the iterator pattern on your criteria. This could give you a performance benefit. Instead of processing all the houses at once, you can return an 
iterator and filter the whole set one by one.

1. You want to create a hierarchy of types because you have some implementation code you want to share between all types. You also have some method signatures you want
to share. What should you use?
A. An interface
Incorrect: An interface won’t let you share any implementation code, only the public member signatures.
B. A class with virtual methods
Incorrect: A class requires you to have an implementation for every member. It doesn’t give you the option to only declare a member signature.
*C. An abstract class
Correct: An abstract class enables you to share both implemented methods and method signatures that a derived class needs to implement.
D. A sealed class
Incorrect: A sealed class can’t be inherited.

2. You want to create a type that can be easily sorted. Which interface should you implement?
A. IEnumerable
Incorrect: IEnumerable should be implemented on collection-like types so they can be easily iterated over.
*B. IComparable
Correct: IComparable enables objects to be compared to each other. It returns an integer value that represents the relative position as smaller than 0, 0 or larger than 0.
C. IDisposable
Incorrect: IDisposable should be implemented on types that access unmanaged resources and that need to release them.
D. IUnknown
Incorrect: IUnknown is used only when working with the COM.

3. You want to inherit from an existing class and add some behavior to a method. Which steps do you have to take? (Choose all that apply.)
A. Use the abstract keyword on the base type.
Incorrect: When you mark the base type as abstract, you can’t create an instance of it. You can’t use both the base and the derived type as concrete types in your code.
*B. Use the virtual keyword on the base method.
Correct: Marking the method in the base class as virtual enables it to be overridden by derived classes.
C. Use the new keyword on the derived method.
Incorrect: The new keyword hides the method in the base class. You shouldn’t use it when you want to extend the behavior from the base class.
*D. Use the override keyword on the derived method. 
Correct: The override keyword enables you to override a method marked as virtual in a base class.

=========================================================================================================================================================================
=========================================================================================================================================================================

OBJECTIVE 2.5: THOUGHT EXPERIMENT

You are creating your own optimized object-relational mapper. You allow the user to map types one-on-one to a table in the database. You also use special attributes
for security reasons. For example, a type can be decorated with an AuthorizeAttribute to make sure that only specific users can access a certain table. You use a lot
of reflection in your app and you start seeing some performance problems. You are also thinking about a generator that will create types that map exactly to an existing database.

1. Why do you use an attribute instead of inheriting from an interface? Wouldn’t that be easier than adding a whole new concept to C#?
Although interface inheritance describes an “is-a-kind-of” relation, but you can’t say that your type is “a kind of AuthorizedObject.” Instead, you use attributes to say 
something about another type, which is why C# contains metadata. Inheritance should not be used to decorate a type with certain information.

2. What can you do about the performance problems with using reflection?
Reflection can be a really slow process. You can replace reflection with expression trees. When you are mapping data to a custom type, you can build an expression tree
(and cache it!). The expression tree can be compiled to native code. Of course, you will still have the penalty of doing this extra step, but it will be much faster than reflection.

3. Which technique would you use to create your generator?
For generating code, you can use the CodeDOM. A CompilationUnit created by the CodeDOM can be outputted as a source file. 


1. You want to read the value of a private field on a class. Which BindingFlags do you need? (Choose all that apply.)
*A. Instance
Correct: The field is a nonstatic instance field.
B. DeclaredOnly
Incorrect: DeclaredOnly is used when you don’t want to include inherited members.
C. Static
Incorrect: The field is not static; it’s a per-instance field.
D. NonPublic
Correct: Nonpublic is necessary because the field is private.

2. You need to create an attribute that can be applied multiple times on a method or a parameter. Which syntax should you use?
A. [AttributeUsage(AttributeTargets.GenericParameter | AttributeTargets.Method, AllowMultiple = true)]
Incorrect: The AttributeTargets.GenericParameter can be applied to generic parameters. It’s not used for regular method arguments.
*B. [AttributeUsage(AttributeTargets.Method | AttributeTargets.Parameter, AllowMultiple = true)]
Correct: The Attribute targets both Methods and Parameters. It can also be applied multiple times.
C. [AttributeUsage(AttributeTargets.All)]
Incorrect: With AttributeTargets.All, the attribute can be applied to all types. It also can’t be applied multiple times.
D. [AttributeUsage(AttributeTargets.Method | AttributeTargets.Parameter)]
Incorrect: Because AllowMultiple is false by default, this attribute can’t be applied multiple times.

3. You want to create a delegate that can filter a list of strings on a specific value. Which type should you use?
A. Action<bool, IEnumerable<string>>.
Incorrect: An Action doesn’t return a value. It also takes a Boolean input instead of the list of strings and the filter value.
B. Func<IEnumerable<string>, IEnumerable<string>>.
Incorrect: This delegate doesn’t have a parameter for the value to filter on.
*C. Func<string, IEnumerable<string>, IEnumerable<string>>.
Correct: It takes both the input list and the value to filter on and returns the filtered list.
D. Func<IEnumerable<string>>.
Incorrect: This returns only a list of strings. It doesn’t have an argument for the filter parameter or the original list.


================================================================================================================================================
================================================================================================================================================

OBJECTIVE 2.6: THOUGHT EXPERIMENT

You have created your first Windows 8 app. It’s a nice game that enables users to take a video of themselves describing a word. Others have to guess; that way, they
can earn points that enable them to create a longer video. One day you wake up and you suddenly realize that Microsoft chose your app as its app of the week. Your web server 
that’s running all the logic of the game is trembling under the user load because of the sudden popularity. Both memory and CPU pressure are a lot higher than you expected. 
You have some types that are qualified to be a value type but at the time of creating your app, you just used classes.

1. How can using value types when possible improve your performance? Or could it be that your performance will deteriorate more?
Reference types are on the heap and managed by the garbage collector. Value types are on the stack most of the time and are freed when the current method ends. When
a value type is on the stack, it takes up less memory than it would on the heap. However, if a value type is enclosed in a reference type, it’s still on the heap. Changing the
type to a struct is no guarantee that your memory pressure will drop.

2. Why is implementing IDisposable important to reduce memory pressure? Is it always the best to call Dispose on an element as soon as you are done with it?
IDisposable gives you a way to explicitly free up unmanaged resources and you won’t have to wait for the garbage collector to free memory. However, calling Dispose is something that takes up 
CPU time. When leaving things to the garbage collector, the garbage collector will decide when is the best time to start calling finalizers. There is a compromise to make between explicitly or 
implicitly freeing your resources

3. Should you implement a finalizer on all your types that implement IDisposable?
A class that implements IDisposable should have some unmanaged resources. A finalizer is important for making sure that an item always frees the unmanaged resources, even when Dispose is not called. 
However, a class with a finalizer is threaded in a special way. The object is added to a finalization queue and is kept in memory until the finalizer has run. It’s important to make sure that when 
Dispose is called, the object is explicitly removed from the finalization queue.

4. You have some items that are used a lot. Would it be wise to put them in a static field so you don’t have to re-create them each time?
A static field is a root reference; the garbage collector will never free an object that is referenced by a static field. In this case, it would be better to use a cache that keeps track of which 
objects should be kept in memory. A caching algorithm that decides on how frequently an object is accessed can make sure that your objects are around. However, when there is a memory shortage, the 
cache can turn some objects into WeakReferences and make sure they can be garbage collected.

1. You are about to execute a piece of code that is performance-sensitive. You are afraid that a garbage collection will occur during the execution of this code. Which method should you call before executing your code?
A. GC.RemoveMemoryPressure()
Incorrect: RemoveMemoryPressure should be called only after calling AddMemoryPressure to inform the runtime that a managed object uses a large amount of unmanaged memory.
B. GC. SuppressFinalize()
Incorrect: SuppressFinalize should be called in the Dispose method of an object to inform the runtime that the object doesn’t need to be finalized any more.
*C. GC.Collect()
Correct: Collect will execute a garbage collection, freeing as much memory as possible at that time, which can be a very expensive process. This won’t prevent the garbage collector from executing during your 
time-sensitive code, but it will make it less likely to happen.
D. GC.WaitForPendingFinalizers()
Incorrect: WaitForPendingFinalizers suspends the current thread so all finalizers that are on the finalization queue can run. This will free some memory (for all objects that are waiting for finalization). 
Normally, however, you call this code after calling Collect if you want to make sure that all finalizers have run.

2. An object that is implementing IDisposable is passed to your class as an argument. Should you wrap the element in a using statement?
A. Yes, otherwise a memory leak could happen.
Incorrect: A memory leak won’t happen because the finalizer of the class will eventually execute and dispose of the element. Disposing of the object in your method will cause an ObjectDisposedException 
to be thrown in other code that uses the object.
B. No, you should call Close on the object.
Incorrect: The Close method is sometimes used as a secondary method that internally calls Dispose. It’s implemented on types such as File. The same reasoning applies as with answer A.
C. No, you should use a try/finally statement and call Dispose yourself.
Incorrect: A using statement is equivalent to a try/finally statement with a Dispose call. However, you don’t want to dispose of the item because the calling code could depend on the object being in a usable state.
*D. No, the calling method should use a using statement.
Correct: The calling code knows what the lifetime of the object should be and should decide when to dispose of the object.

3. Your application is using a lot of memory. Which solution should you use?
A. Turn all references into WeakReferences.
Incorrect: A WeakReference is not an equivalent to an efficient caching strategy. Turning all items into WeakReferences will complicate your code (you have to see whether the memory is cleared). 
It could potentially increase your memory usage because the WeakReference itself also takes up memory.
B. Set all references to null when you are done with them.
Incorrect: Setting references to null is optimized away by the compiler. Unlike some other languages, it doesn’t explicitly free any memory.
*C. Use a caching algorithm to decide which objects can be freed.
Correct: A caching strategy is the best solution. You can decide whether you want to free memory based on usage, a timestamp, or some other criteria.
D. Use a background thread to call GC.Collect() on a scheduled interval. 
Incorrect: Calling GC.Collect on a scheduled interval won’t improve your memory usage. Memory is freed only when there are no root references to an object. GC.Collect will stall your execution thread, 
making things slower, while not freeing any more memory than waiting for a regular Collect to take place.


================================================================================================================================================
================================================================================================================================================

OBJECTIVE 2.7: THOUGHT EXPERIMENT

You are working on a localized application to be used for time tracking. A team can use it to track time for various projects and tasks, and make sure that all billable time is correct. The application consists 
of a web front end based on ASP.NET and a desktop application that uses C#. Suddenly, your manager announces that your application is going global. You currently support only the English language; you didn’t take 
globalization into account when first architecting the application. Now you have to support Spanish and German.

1. Make a list of the things you have to keep in mind when updating your application for globalization.
This is not a trivial task to do. Building globalization into an existing application requires more effort than taking it into account from the start.
The areas you will have to focus on are the display of text. Especially because this is a time tracking application there will be a lot of dates and times that are displayed.
There are a few areas you will have to focus on:
* Make sure that all string comparisons use an explicit overload that takes a StringComparison object.
* Use StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase when comparing strings in a culture-agnostic way.
* Use StringComparison.CurrentCulture when displaying text to the user.
* Make sure that all persisted text is persisted with the invariant culture.
* Make sure that you are not using String.Compare or CompareTo for equality testing.
* Implement IFormattable for custom types that are displayed to the user to make sure that all culture settings are respected.
* Use the correct format strings when displaying numbers, dates, and times to the user. 

OBJECTIVE REVIEW

1. You want to display only the date portion of a DateTime according to the French culture. What method should you use?
A. dt.ToString(new CultureInfo(“fr-FR”))
Incorrect: Only specifying the culture will give you the full date and time.
B. dt.ToString(“M”, new CultureInfo(“fr-FR”));
Incorrect: Specifying “M” as the format string results in ”22 avril” without the year.
C. dt.ToString(“d”);
Incorrect: This will give the date in the correct format, but not with the French culture.
*D. dt.ToString(“d”, new CultureInfo(“fr-FR”));
Correct: This will give the date in the correct French format.

2. You want your type to be able to be converted from string. Which interface should you implement?
*A. IFormattable
Correct: IFormattable provides the functionality to format the value of an object into a string representation. It is also used by the Convert class to do the opposite.
B. IFormatProvider
Incorrect: IFormatProvider is used to retrieve an object that controls formatting, not the actual formatting.
C. IComparable
Incorrect: IComparable is used to sort items.
D. IConvertible
Incorrect: IConvertible defines methods to convert a type to an equivalent CLR type.

3. You are parsing a large piece of text to replace values based on some complex algorithm. Which class should you use?
A. StringReader
Incorrect: StringReader is an adapter of the StringBuilder class so that it can be used in places where a TextReader is required.
*B. StringBuilder
Correct: The StringBuilder class is most efficient when changing large amounts of strings.
C. StringWriter
Incorrect: The StringWriter is used in places where a TextWriter is required. It’s an adapter of the StringBuilder.
D. String
Incorrect: The regular String class is immutable, so it’s not efficient to use when changing large amounts of strings.


==================================================================================================================================================
==================================================================================================================================================

OBJECTIVE 3.1: THOUGHT EXPERIMENT

You have developed a complex web application and deployed it to production. The application is a new hybrid of wiki and a forum. Users can use it to brainstorm on ideas and write a document together.
Suddenly users start contacting your support desk. They are all reporting ”that your application looks strange.” It suddenly contains extra URLs that link to external websites that are mixed with the original website’s layout.
1. What could be the problem?
It looks like malicious users are entering HTML in the text fields. This data gets submitted to the server and rendered the next time the page is viewed.

2. How will you solve it?
You need to use regular expressions to restrict the user input. By making clear which characters you allow, you can strip the input of the HTML characters and make sure they are not showing up in the page layout.


OBJECTIVE REVIEW

1. A user needs to enter a DateTime in a text field. You need to parse the value in code. Which method do you use?
A. DateTime.Parse
Incorrect: Parse will throw an exception when the user enters an invalid date, which is not uncommon.
*B. DateTime.TryParse
Correct: TryParse will see whether the entered value is a valid date. If not, it will return gracefully instead of throwing an exception.
C. Convert.ToDateTime
Incorrect: Convert.ToDateTime uses Parse internally. This will throw an exception when entered data is in the wrong format.
D. Regex.Match.
Incorrect: RegEx.Match can be used to see whether the input is a valid date. It can’t convert the input string to a DateTime object.

2. You are working on a globalized web application. You need to parse a text field where the user enters an amount of money. Which method do you use?
A. int.TryParse(value, NumberStyles.Currency, UICulture);
Incorrect: Money should not be stored in an integer because it can’t store decimal numbers.
*B. decimal.TryParse(value, NumberStyles.Currency, UICulture);
Correct: You need to specify the NumberStyles.Currency and the culture that the user is using to parse the DateTime correctly.
C. decimal.TryParse(value, ServerCulture);
Incorrect: Using the server culture doesn’t account for the differences in user culture. You also need the NumberStyles.Currency parameter to make sure the user can enter a currency symbol.
D. decimal.TryParse(value)
Incorrect: Leaving off the culture defaults to the culture of the operating system. You also need the NumberStyles.Currency parameter to make sure the user can enter a currency symbol.

3. You need to validate an XML file. What do you use?
A. JavaScriptSerializer
B. RegEx
C. StringBuilder
*D. XSD

============================================================================================================
============================================================================================================

OBJECTIVE 3.2: THOUGHT EXPERIMENT

You are working on an application that helps users track their time and shows them when they are most productive. The application runs on a server with a web, 
desktop, and mobile front end being developed with the .NET Framework.
You are assigned the task of determining which security features should be used in the application.
Make a list of the possible technologies that can be used to secure the application.

You can use numerous security features, including these:
*Digital certificates to make sure the application can be safely installed on desktop machines.
*Asymmetric encryption to send data to the server by using the public key to encrypt the data.
*Asymmetric encryption to send data from the server to the client. The server encrypts with the private key; the client decrypts with the public key.
*Code access permissions to make sure that your application can run in sandboxed environments.


OBJECTIVE REVIEW
1. Bob and Alice are using an asymmetric algorithm to exchange data. Which key should they send to the other party to make this possible?
A. Bob sends Alice his private key, and Alice sends Bob her public key.
Incorrect: The private key should always be kept confidential.
B. Bob sends Alice his private key, and Alice sends Bob her private key.
Incorrect: The private key should always be kept confidential.
*C. Bob sends Alice his public key, and Alice sends Bob her public key.
Correct: By sending each other their public key, they can then encrypt data with the other party’s public key to send them data.
D. Bob sends Alice his public key, and Alice sends Bob her private key.
Incorrect: The private key should always be kept confidential

2. You need to encrypt a large amount of data. Which algorithm do you use?
A. SHA256
Incorrect: SHA256 is a hashing algorithm. It can’t be used to encrypt data.
B. RSACryptoServiceProvider
Incorrect: RSACryptoServiceProvider is an asymmetric encryption algorithm. Asymmetric algorithms are not suited for encrypting large amounts of data.
C. MD5CryptoServiceProvider
Incorrect: MD5CryptoServiceProvider is a hashing algorithm. It can’t be used to encrypt data.
D. AesManaged
Correct: AesManaged is a symmetric algorithm that can be used to encrypt large amounts of data.

3. You need to send sensitive data to another party and you want to make sure that no one tampers with the data. Which method do you use?
*A. X509Certificate2.SignHash
Correct: Using the digital certificate X509 can be used to sign hashed data. If the other party uses the Verify method, it can check that the hash hasn’t changed.
B. RSACryptoServiceProvider.Encrypt
Incorrect: This method encrypts the data with an asymmetric algorithm. It doesn’t ensure that the data hasn’t been tampered with.
*C. UnicodeEncoding.GetBytes
Correct: UnicodeEncoding.GetBytes converts a string to a byte sequence. It doesn’t protect the data in any way.
D. Marshal.ZeroFreeBSTR
Incorrect: The Marshal class should be used when working with System.SecureString. The ZeroFreeBSTR method can be used to zero out an area of memory that contained an insecure string.


============================================================================================================
============================================================================================================

OBJECTIVE 3.3: THOUGHT EXPERIMENT

You are discussing the reasons why you want to sign an assembly that you have built. The assembly will be distributed with a desktop application you are building. The assembly won’t be shared by other applications.
1. Should you sign the assembly?
Yes, you should sign the assembly.
2. What are the advantages and disadvantages of signing? 
Signing the assembly protects the assembly against tampering. The .NET Framework will check that the assembly hasn’t been altered between signing and running.
Signing is also a requirement to be able to use a digital certificate so users of your application will know that you are the publisher of the application.
A disadvantage could be that you can no longer reference other nonsigned assemblies. If you own these assemblies, you can sign them yourself. If not, you would have to ask their publisher to sign them.

OBJECTIVE 3.3: REVIEW

1. You are building a strong-named assembly and you want to reference a regular assembly to reuse some code you built. What do you have to do?
A. You first need to put the assembly in the GAC.
Incorrect: An assembly in the GAC needs to be strongly named. Your assembly still won’t be able to reference the nonsigned assembly.
B. Nothing. Referencing another assembly to use some code is always possible.
Incorrect: A strong-named assembly cannot reference a non-strong-named assembly.
*C. You need to sign the other assembly before using it.
Correct: You need to strongly name the other assembly before you can reference it.
D. You need to use the public key token of the other assembly to reference it.
Incorrect: The public key token is a part of the manifest of a strong-named assembly. The non-strong-named assembly doesn’t have this key information. It needs to be strongly named first.

2. You are building an assembly that will be used by a couple of server applications. You want to make the update process of this assembly as smooth as possible. Which steps should you take? (Choose all that apply.)
A. Create a WinMD Metadata file.
Incorrect: A WinMD file is used by the WinRT in Windows 8. It shouldn’t be used outside of this context.
*B. Deploy the assembly to the GAC.
Correct: A shared assembly can be deployed in the GAC. Other applications can reference it there. When you want to update it, you can do so by deploying the
new version to the GAC. By using configuration files, you can then let other applications reference your new assembly.
C. Add an assemblyBinding section to each client application that points to the location of the assembly.
Incorrect: You can use the assemblyBinding configuration element to add extra search locations for an assembly. This would ask for changes to each client application, however. 
The GAC is the location where a shared assembly needs to be deployed.
D. Strongly name the assembly.
Incorrect: Strongly naming an assembly doesn’t make it a shared assembly. Each application would still require its own copy.

3. You want to deploy an assembly to a shared location on the intranet. Which steps should you take? (Choose all that apply.)
*A. Strongly name the assembly.
Correct: Strongly naming the assembly is required to be able to reference it on the intranet.
*B. Use the codebase configuration element in the applications that use the assembly.
Correct: The codebase configuration element can be used to have local client applications know they can find an assembly on another location such as the intranet.
C. Deploy the assembly to the GAC.
Incorrect: Deploying it to the GAC won’t put the assembly on the intranet.
D. Use the assemblyBinding configuration element with the probing option.
Incorrect: The probing option can be used only to give additional locations relative to the application path. It can’t be used to point to the intranet


=====================================================================================================================
=====================================================================================================================
OBJECTIVE 3.4: THOUGHT EXPERIMENT

You are working in the support department of your organization. A customer phones you to report an error in a web application that you are hosting on your own servers.

1. You want to start debugging this application remotely.
No, you don’t have to do this. Although a debug version will contain more information, you can debug the release version if you have the correct PDB file.

2. Do you need to deploy a debug version to the server?
You need to make sure that you have the correct PDB file that matches the build that’s running on your server. You need this file to launch a debugging session.

4. How can a Symbol Server help you?
A Symbol Server stores your PDB files and helps your debugger find the correct version. If you have a Symbol Server in place, you can easily start a debugging session to your server, 
and your debugger will find the correct PDB files automatically.

OBJECTIVE 3.4: REVIEW

1. You are ready to deploy your code to a production server. Which configuration do you deploy?
A. Debug configuration
Incorrect: A debug configuration is not fully optimized and is not suitable for a production environment.
*B. Release configuration
Correct: A release configuration is fully optimized and will give the best results in a production environment.
C. Custom configuration with PDB files
Incorrect: PDB files are necessary only when debugging an application.
D. Release configuration built with the /debug:full compiler flag
Incorrect: The /debug:full flag adds extra information to your application for debugging purposes.

2. You are debugging an application for a web shop and are inspecting a lot of Order classes. What can you do to make your debugging easier?
*A. Use the DebuggerDisplayAttribute on the Order class.
Correct: The DebuggerDisplayAttribute helps you in supplying a more helpful description when inspecting an item through the debugger.
B. Override ToString on the Order class.
Incorrect: Overriding ToString does help, but a better solution is to use the DebuggerDisplayAttribute because this won’t influence your code in production.
C. Use the ConditionalAttribute on the Order class.
Incorrect: The ConditionalAttribute can be used to remove code from your compiled application. Most of the time, it’s used to remove certain calls when doing a release build.
*D. Use the #line compiler directive to make sure you can find the correct location when an exception occurs.
Incorrect: The #line directive is used to change the line numbers of your code. Normally, this won’t be necessary.

3. You are using custom code generation to insert security checks into your classes. When an exception happens, you’re having troubling finding the correct line in your source code. What should you do?
A. Use #error to signal the error from your code so that it’s easier to find.
Incorrect: #error will signal an error at compile time.
B. Use #line hidden to hide unnecessary lines from the debugger.
Incorrect: #line hidden will remove the extra generated lines from the debugger, but it won’t restore your line numbers.
C. Use the ConditionalAttribute to remove the security checks from your debug build.
Incorrect: This is a dangerous solution because it creates different behavior between debug and release builds. You won’t be able to test your security checks while working with a debug build.
*D. Use the #line directive with the correct line numbers in your generated code to restore the original line numbers.
Correct: The #line directive can be used to tell the compiler to change the line number of a line of code. This way, you can remove the line numbers for the generated code so that exceptions will match the original code.

========================================================================================================================================================
========================================================================================================================================================
OBJECTIVE 3.4: THOUGHT EXPERIMENT


You are building an online web shop that will be hosted in a distributed environment. Your web shop needs to scale well, so performance is an important concept.
1. Which events would you write to a trace source in a web shop?
* Critical: An irrecoverable error occurs, such as the database which is down so users can’t place any orders.
* Error: While submitting an order, the system notices that the database can’t be reached and tries to resubmit the order.
* Warning: The time it takes to submit an order is suddenly taking longer than expected.
* Information: A new order is submitted successfully.
* Verbose: Here you can trace all application events such as the beginning of the order process, how the user navigates through your web shop, and which decisions he makes.

2. How can you use performance counters to keep an eye on your performance?
You can use performance counters to keep track of how many orders are submitted and how long it takes to save them to the database. In the same way, you can see whether loading the product catalog is taking too long.

OBJECTIVE 3.4: REVIEW

1. You are using the TraceSource class to trace data for your application. You want to trace data when an order cannot be submitted to the database and you are going to perform a retry. Which TraceEventType should you use?
A. Information
Incorrect: A failing order is not something that should be seen as only an informative event. It should be treated as something critical.
B. Verbose
Incorrect: Verbose should be used only for very detailed tracing messages.
C. Critical
Incorrect: You can still recover from the error, which makes it a severity of Error, not Critical.
*D. Error
Correct: You should let the operators know that something is wrong and that you are trying to recover. If recovery fails, you should log a Critical event.

2. Users are reporting errors in your application, and you want to configure your application to output more trace data. Which configuration setting should you change?
A. NumberOfItems32
Incorrect: NumberOfItems32 is an option for creating a performance counter.
B. Listener
Incorrect: A listener determines what is done with the tracing events. It doesn’t influence which events are traced.
C. Filter
Incorrect: A filter is used to filter the message that a listener processes. It doesn’t influence which events are traced.
*D. Switch
Correct: The switch value determines which trace events should be handled. By lowering the severity for the switch, you will see more trace events in your output.

3. You are working on a global application with lots of users. The operation staff requests information on how many user logons per second are occurring. What should you do?
A. Add a TraceSource and write each logon to a text file.
Incorrect: Writing the events to a text file will still require a tool to parse the text file and give results to the operation staff.
*B. Implement a performance counter using the RateOfCountsPerSecond64 type.
Correct: This performance counter will help the operation staff to see exactly what happens every second.
C. Instrument your application with the profiler so you can see exactly how many times the logon method is called.
Incorrect: Profiler instrumentation will really slow down the performance of your application. It’s also something that’s not easy readable by your operations staff.
D. Use the EventLog class to write an event to the event log for each logon.
Incorrect: Although the event log can be read by the operation staff, they will have to manually count all events to calculate the logons per second. 

========================================================================================================================================================
========================================================================================================================================================
OBJECTIVE 4.1: THOUGHT EXPERIMENT

You need to create a custom File Explorer that uses WPF for a customer. Other members of your team work on the user interface of the File Explorer. You are tasked with creating the code that handles all the I/O. 
The File Explorer should be an abstraction over the file system. It shouldn’t show any drives; instead, it should group files into categories that depend on the location and file type. The categories
and locations are given to you by the customer. For example, you have a category “Administration” that contains Microsoft Office documents from multiple locations.

1. Which classes do you plan to use?
You can use DirectoryInfo and FileInfo classes for searching through folders for the specified files. You can use the Path class for making sure that the locations given to you by the customer are valid.

2. How will you filter the files by specific file types?
You can use a search pattern when looking for files. By using a search pattern such as “*.docx,” you can find all Word documents in a directory.

3. Do you need asynchronous code?
Yes. You are working with I/O in a desktop application. If you use synchronous code, the user interface appears to crash or become unresponsive each time you iterate over your folders or files. 
By making the application asynchronous, the user interface remains responsive.


OBJECTIVE REVIEW

1. You are creating a new file to store some log data. Each time a new log entry is necessary, you write a string to the file. Which method do you use?
A. File.CreateText
Incorrect: File.CreateText would create a new file each time. You only want to append some text.
B. FileInfo.Create
Incorrect: FileInfo.Create would return a FileStream to a newly created file. You would need to encode your data to a byte array to write it to the stream.
C. File.Create
Incorrect: File.Create is the static equivalent of FileInfo.Create. It returns a FileStream that would require encoding to write your log entries.
*D. File.AppendText
Correct: File.AppendText adds some text to the end of a file

2. You have built a complex calculation algorithm. It takes quite some time to complete and you want to make sure that your application remains responsive. What do you do?
A. Use async/await.
Incorrect: async/await is not usable when working with a CPU-bound algorithm.
B. Run the code synchronously.
Incorrect: Running the code synchronously would make the user interface unresponsive.
*C. Use Task.Run.
Correct: Task.Run will run the CPU-bound code on a separate thread. This will free the user interface thread to make sure that the application remains responsive.
D. Use a BackgroundWorker.
Incorrect: BackgroundWorker is retired. The new Task Parallel Library replaces it

3. You are writing an application that will be deployed to Western countries. It outputs user activity to a text file. Which encoding should you use?
*A. UTF-8
Correct: UTF-8 is a general-purpose encoding format that works on many operating systems.
B. UTF-7
Incorrect: UTF-7 is used as a protocol for newsgroup and e-mail. It’s not as secure (see http://en.wikipedia.org/wiki/UTF-7#Security) as the other encodings, requires
more space, and it’s slower in encoding/decoding. UTF-8 should be used whenever possible.
C. ASCII
Incorrect: Because ASCII supports only a limited range of characters, it is inadequate in most cases for international applications.
D. UTF-32
Incorrect: UTF-32 requires a lot of space for storing characters (4 bytes for each character). It is used when applications want to encode Unicode supplementary characters 
(for example, Chinese characters) as one single glyph. You need this only when the encoded space of such characters is important to you. If you don’t need the Unicode supplementary characters, 
you can use UTF-8. If you do need them. UTF-16 can be used except when you have strict space requirements.
 


========================================================================================================================================================
========================================================================================================================================================
OBJECTIVE 4.2: THOUGHT EXPERIMENT

You are designing a new application that stores data about weather conditions throughout the world. Your business model relies on selling this data to customers so they can use it in their own applications. 
You use a relational database to store your data, and you access your data through web services that can be accessed by authorized users. You also create regular XML dumps for users that want a local
copy of the data.

1. What are the advantages and disadvantages of using the Entity Framework?
Using the Entity Framework can improve your development speed. You won’t have to think about converting data from your database to objects. It will also manage change tracking for you and convert your LINQ queries to SQL. 
However, this comes at a(sometimes a significant) performance cost. If you don’t really need an object model to expose your data to your clients, you could use plain SQL queries to achieve more performance.

2. Which techniques do you plan to use for your web services?
For your web services, you can use WCF.to write regular classes and use some attributes on them to expose them as services. By separating the configuration, you can then expose multiple endpoints for different user types. 
You can, for example, use a JSON endpoint or an XML endpoint.

3. How will you expose your data as XML?
You can use the XmlWriter class for this. Because you are dealing with a lot of data, XmlDocument can be too slow. When you don’t need to edit data but only output it, XmlWriter is a good choice


OBJECTIVE REVIEW

1. You want to update a specific row in the database. Which objects should you use? (Choose all that apply.)
*A. SqlCommand
Correct: You need a SqlCommand to execute your update query against the database.
B. SqlDataReader
Incorrect: A SqlDataReader is used when you select some data from your database. You don’t use it when executing an update command.
*C. SqlConnection
Correct: You need a SqlConnection to establish a connection to your database. The SqlCommand uses this connection to execute the update query.
D. TransactionScope
Incorrect: A Transaction is not necessary when executing only a single command. If an exception occurs, no other queries have to be canceled.

2. You are planning to build an application that will use an object-oriented design. It will be used by multiple users at the same time. Which technology should you use?
A. XML files
Incorrect: Storing your data in a plain XML file doesn’t allow multiple users to read and update it at the same time.
*B. Entity Framework
Correct: A relational database that stores the data with the Entity Framework mapping it to your objects helps you with quickly developing your application.
C. ADO.NET
Incorrect: A relational database is the best option to store your data. Using plain ADO.NET code would require you to manually map your objects to the database, and vice versa.
D. Web service
Incorrect: The dynamic keyword can be used in scenarios in which you want weak typing. It will still throw errors at runtime if an action is not possible.

3. You need to process a large number of XML files in a scheduled service to extract some data. Which class should you use?
*A. XmlReader
Correct: XmlReader is the fastest option when processing a lot of data. Because you only have to read it and not make any changes, this is the best choice.
B. XmlDocument
Incorrect: XmlDocument is not fast enough when working with a large XML file.
C. XmlWriter
Incorrect: The XmlWriter is used to create XML files, not to read them.
D. FileStream
Incorrect: Using a FileStream would treat the XML file as plain text. You lose the benefits of the hierarchical nature of your document. Furthermore, parsing it as plain text is not a trivial task.

========================================================================================================================================================
========================================================================================================================================================
OBJECTIVE 4.3: THOUGHT EXPERIMENT

You are starting a new project in which you can use LINQ for the first time. You have never worked with LINQ before, but you have studied it on your own time and you see its advantages.
You see possibilities for using LINQ to Entities, LINQ to Objects, and LINQ to XML in your projects and you try to introduce them in your company.
However, some of your coworkers are having some doubts. Will LINQ be fast enough? Is it easy to maintain? Do we need to use the method or query syntax?
Try to help your colleagues by answering these questions for them:

1. Does LINQ have any performance problems? If so, should it be avoided?
Although it is true that LINQ is not always as fast as a manual loop or filter, you get a lot of other benefits. LINQ to Entities translates your LINQ query to SQL, which enables you to create strongly typed queries against your database. 
LINQ to XML uses it to process an XML file with a more fluent syntax than if you do it by hand. The biggest advantage of using LINQ is that you can use a uniform, strongly typed way of querying against multiple different data sources. 
Most of the time, development time is more important than premature optimizations. If you do encounter a performance bottleneck, you can measure your code and optimize your queries in a targeted manner.

2. Is LINQ easy to maintain?
LINQ is strongly typed and easier to read than a handwritten loop or query. LINQ offers operators such as Sum, Average, and GroupBy that can make writing complex queries much easier. 

3. What are the differences between method and query syntax? Which should be used?
Query syntax is translated into method syntax by the compiler. Not all operators are supported in query syntax. If you need a special operator that’s available only in method syntax, you are forced to use method syntax. 
Query syntax is more readable and should be used whenever possible.


Objective review

1. You have a list of dates. You want to filter the dates to the current year and then select the highest date. Which query do you use? (Choose all that apply.)
A. DateTime result = dates.Where(d => d == DateTime.Now).OrderBy(d => d).First();
Incorrect: Comparing DateTime.Now to the dates will give you only the dates for today, not for the whole year. Also, using OrderBy instead of OrderByDescending will give you the lowest date, not the highest.
*B. DateTime result = dates.Where(d => d.Year == DateTime.Now.Year).OrderByDescending(d => d).FirstOrDefault();
Correct: This will return the highest date for the current year. If your filter can’t find a value for the current year, it will return ‘1-1-0001 00:00:00’ (DateTime.MinValue).
C. DateTime result = dates.Where(d => d.Year == DateTime.Now.Year).OrderByDescending(d => d).First();
Incorrect: If your filter doesn’t return a value, you will get an error. You should use FirstOrDefault instead.
D. DateTime result = dates.Where(d => d.Year == DateTime.Now.Year).OrderByDescending(d => d).Single();
Incorrect: Using Single will throw an exception if there are multiple dates for the current year.

2. You are trying to use a LINQ query, but you are getting a compile error that the Where method cannot be found. What should you do? (Choose all that apply.)
*A. Add a using System.Linq statement.
Correct: You need to add a using statement for LINQ to make sure that all LINQ extension methods are available.
*B. Check that you are using a type that implements IEnumerable.
Correct: LINQ is implemented as extension methods on IEnumerable. If your type does not implement this, you can’t use the extension methods.
C. Change your query from query to method syntax.
Incorrect: The compiler changes your query syntax to method syntax. Using one or the other doesn’t change anything.
D. Change the type of your query to var.
Incorrect: Using implicit typing lets the compiler determine the result of your query. It doesn’t help the compiler find the Where method.

3. You are using the following LINQ to Entities query:

var query = from p in myContext.Products
            where p.Price < 50
            select p;
int numberOfItems = query.Count();
var products = query.ToList();

You are suffering performance problems. How can you improve your query? (Choose all that apply.)
*A. Avoid hitting the database multiple times.
Correct: Because of the deferred execution nature of LINQ, you execute the query twice—one for getting the number of items, and one for getting all the products. You can change your query to get both these numbers in one call.
B. Don’t execute ToList() on the query.
Incorrect: ToList() is necessary for running the query. If you never iterate the query, you won’t get any results.
*C. Use paging.
Correct: Paging can help limit the number of items that you retrieve.
D. Change the query to method syntax.
Incorrect: Method syntax is compiled to query syntax. It doesn’t make any functional difference.

331